<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Smile Score</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: sans-serif;
      margin: 0;
      background: #f9f9f9;
    }
    #logo {
      width: 150px;
      margin: 1rem auto;
      display: block;
    }
    #upload-btn {
      margin: 1rem;
    }
    #canvas {
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      margin-top: 1rem;
    }
    #result {
      font-size: 1.2rem;
      margin-top: 1rem;
    }
    #download-btn {
      margin-top: 1rem;
      background: #4CAF50;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 8px;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <img id="logo" src="assets/mid-logo.png" alt="Mid Logo">
  <input type="file" id="upload-btn" accept="image/*">
  <canvas id="canvas"></canvas>
  <div id="result"></div>
  <button id="download-btn">Download Result</button>

  <!-- Import MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultEl = document.getElementById('result');
    const uploadBtn = document.getElementById('upload-btn');
    const downloadBtn = document.getElementById('download-btn');
    const resultCache = {}; // stores results by hash

    // MediaPipe FaceMesh Setup
    const faceMesh = new FaceMesh({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    uploadBtn.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const hash = await hashImage(file);

      if (resultCache[hash]) {
        console.log("Using cached result");
        displayResult(resultCache[hash]);
        return;
      }

      const img = await loadImage(URL.createObjectURL(file));
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      faceMesh.onResults((results) => {
        if (!results.multiFaceLandmarks.length) {
          resultEl.textContent = "No face detected. Please try again.";
          return;
        }

        const landmarks = results.multiFaceLandmarks[0];

        // Draw detected face mesh (for debugging) â€” optional
        // drawConnectors(ctx, landmarks, FACEMESH_LIPS, {color: '#FF0000', lineWidth: 1});

        const teethMask = detectTeethMask(img, landmarks);
        if (teethMask) {
          drawOverlay(teethMask);
        }

        const smileScore = computeSmileScore(teethMask, landmarks);
        const discount = getDiscount(smileScore);

        const output = { smileScore, discount, img };
        resultCache[hash] = output;
        displayResult(output);
      });

      await faceMesh.send({ image: img });
    });

    downloadBtn.addEventListener('click', () => {
      const a = document.createElement('a');
      a.href = canvas.toDataURL("image/png");
      a.download = `smile_result_${Date.now()}.png`;
      a.click();
    });

    // ---------- FUNCTIONS ----------

    async function hashImage(file) {
      const buffer = await file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      return Array.from(new Uint8Array(hashBuffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    }

    function loadImage(src) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = src;
      });
    }

    function detectTeethMask(img, landmarks) {
      // Get lip polygon
      const lipPoints = landmarks.filter((_, i) =>
        (i >= 61 && i <= 88) // MediaPipe lip indices
      );
      if (!lipPoints.length) return null;

      // Create an offscreen canvas to extract ROI
      const offCanvas = document.createElement('canvas');
      offCanvas.width = img.width;
      offCanvas.height = img.height;
      const offCtx = offCanvas.getContext('2d');
      offCtx.drawImage(img, 0, 0);
      const imageData = offCtx.getImageData(0, 0, img.width, img.height);

      // Simple teeth detection by color threshold (lightness)
      const mask = new Uint8ClampedArray(imageData.width * imageData.height);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const r = imageData.data[i];
        const g = imageData.data[i + 1];
        const b = imageData.data[i + 2];
        const brightness = (r + g + b) / 3;
        mask[i / 4] = brightness > 180 ? 255 : 0; // naive threshold
      }
      return { mask, width: img.width, height: img.height };
    }

    function drawOverlay(teethMask) {
      const imageData = ctx.getImageData(0, 0, teethMask.width, teethMask.height);
      for (let i = 0; i < teethMask.mask.length; i++) {
        if (teethMask.mask[i] === 255) {
          imageData.data[i * 4] = 255;     // red
          imageData.data[i * 4 + 1] = 255; // green
          imageData.data[i * 4 + 2] = 255; // blue
          imageData.data[i * 4 + 3] = 120; // alpha
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function computeSmileScore(teethMask, landmarks) {
      if (!teethMask) return 0;
      const visibleTeeth = teethMask.mask.reduce((a, v) => a + (v === 255 ? 1 : 0), 0);
      const coverage = visibleTeeth / teethMask.mask.length;
      // Simple scoring: coverage normalized to 0-100
      let score = Math.min(100, Math.max(0, coverage * 300)); 
      return Math.round(score);
    }

    function getDiscount(smileScore) {
      const Dmin = 10;
      const Dmax = 30;
      return +(Dmax - (smileScore / 100) * (Dmax - Dmin)).toFixed(2);
    }

    function displayResult({ smileScore, discount }) {
      resultEl.textContent = `Smile Score: ${smileScore}/100 | Discount: ${discount}%`;
      downloadBtn.style.display = "inline-block";
    }
  </script>
</body>
</html>
